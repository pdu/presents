BAT后台开发入门
数组与排序

peng
西七楼

* 经典排序方法

算法的学习是至关重要的，是检验一个程序员水平的重要标准。算法的学习不能死记硬背，一定要理解其中的思想，这样你才能灵活地运用它，因为实际工作中很少有生搬硬照的场景。

七大经典排序算法：

- 插入排序
- 选择排序
- 冒泡排序
- 希尔排序
- 归并排序
- 堆排序
- 快速排序

* 插入排序

先考虑一个子问题：对于长度为n的数组，前n-1位都是递增有序的，如何排序？

	可以自己思考一下，再看下一页的答案

* 插入排序

先考虑一个子问题：对于长度为n的数组，前n-1位都是递增有序的，如何排序？

- 1. 从第1位至第n-1位遍历数组，发现第n位数字应该放在第k位
- 2. 把第k位至第n-1位的数字依次向后挪一位
- 3. 这样长度为n的数组就是递增有序的了


首先长度为1的数组肯定是有序的，按照上述子问题的方法，我们可以对长度为2、长度为3、...、长度为n的数组排序，最终得到一个有序的数组。

* 插入排序

.play -numbers insertion_sort/main.go

* 插入排序

- *时间复杂度* ：O(n*n)
- *空间复杂度* ：额外空间O(1)

O表达式(Big O notation)通常用来在计算机科学中表示算法的复杂度，包括：

- 时间复杂度：衡量算法的运行时间
- 空间复杂度：衡量算法运行所占的空间，比如内存或硬盘等

一般情况下，O表达式代表的是最坏情况下的复杂度。

* 插入排序

- 当数组是逆序的时候，时间复杂度是O(n*n)
- 当数组几乎是有序的时候，时间复杂度是O(n)

另外插入排序的overhead特别小，可以理解为常数等于1。

	算法除了O表达式的复杂度以外，还有常数。一般跟算法的实现相关。

在实际应用中，常数也是一个很重要的因素。有的算法复杂度低，但是常数较高；再加上数据的特点，有时候反而比不上复杂度更高但是常数低的算法。

* 插入排序

插入排序是稳定排序(Stable sort)。

	稳定排序就是对于数组中原本就相对有序的部分，排序之后还是原来的顺序。举个例子，有个数组：
	team := []student{
		{name: "bob", score: 10},
		{name: "alice", score: 5},
		{name: "jimmy", score: 10},
	}
	按照score递增排序后，顺序一定为"alice"、"bob"、"jimmy"则是稳定排序；
	顺序可能为"alice"、"jimmy"、"bob"则不是稳定排序。

典型的应用是：排行榜中，在分数一样的情况下，先得到这个分数的人应该排在前面。

* 插入排序

在理解插入排序算法的过程中，应该要明白一个算法思想：

- 把问题分解为子问题
- 找到问题的初始状态
- 从问题的初始状态，通过子问题，一步步得到最终的解

实际应用中，要灵活的选择算法，有几个重点需要考虑的：

- 复杂度：包括时间复杂度，空间复杂度，常数等
- 实现复杂度：算法实现起来很难，不易于测试和维护的话，也是很大的问题
- 适用性：在特定的业务场景下，是否有更合适的算法？

总的来说，要具体情况具体分析，不能为了用算法而用算法，在满足业务需求的前提下，尽量简洁的解决问题。

* 经典排序算法

以插入排序为例，我们介绍了怎么去分析和实现一个算法。其他的六种排序算法，我们就不在这里铺开说了，推荐几个总结得很好的参考资料：

- [[https://www.toptal.com/developers/sorting-algorithms]]
- [[http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/]]

请确保你在继续后面的课程前，已经完全吃透这七种经典的排序算法。

* 已知一个递增顺序的成绩单，问95分是第几名？

* 

因为成绩单已经是递增有序的，从头到尾遍历成绩单，就能知道95分是多少名。

.play -numbers linear_search/main.go

* 

算法分析：

- 时间复杂度：O(n)
- 空间复杂度：额外空间O(1)
- 常数：O(1)
- 实现复杂度：简单

既然数组已经是有序的了，还有复杂度更低的算法吗？

* 二分搜索

- 对于有序的数组，取其最中间的数：左边的数都不大于它，右边的数都不小于它
- 拿目标跟最中间的数比较：
	目标更大的话，最终解只可能出现在右边的数组中
	否则，最终解只可能出现在左边的数组中
- 问题分解为子问题，并且规模缩小了一半
- 递归子问题直到数组的长度为1，找到最终解

* 二分搜索

.play -numbers binary_search/main.go

* 二分搜索

算法分析：

- 时间复杂度：O(log n)，如果n = 1024，log n = 10
- 空间复杂度：额外空间O(1)
- 常数：O(1)
- 实现复杂度：简单

* 二分搜索

前一种是递归的实现方式，我们换一种非递归的实现：

.play -numbers binary_search2/main.go /START OMIT/,/END OMIT/

* Go: import "sort"

[[https://golang.org/pkg/sort/]] Go提供了非常完整的sort package，能满足项目中几乎所有的跟排序相关的需求，比如：

- 排序
- 稳定排序
- 二分查找
- 自定义排序规则

.play -numbers go_sort/main.go

* 

你有一台16GB内存的Linux服务器，怎么对一个100GB大小的文件排序？

	可以自己思考一下，再看下一页的答案

* 外部排序

外部排序(External sorting)主要用来解决数据太大，无法放入内存中的排序问题。

总体的思想是：

- 把100GB的文件分为10份，每份文件大小为10GB
- 每次读取10GB的文件到内存中，然后分别排序，最后得到10个分别有序的文件
- 这时候可以用前面提到的归并算法
	1. 同时读取10个有序的文件的第一行，也就是最小的那一行
	2. 比较来自10个文件中的这一行数据，把最小的那一行写入结果文件
	3. 对最小的那一行所在的文件，读取下一行
	4. 重复第2-3步，直到处理完所有文件的内容

* 外部排序

外部排序的过程中，运用了一个非常经典的算法思想： *分治* (divide and conquer)

把看起来不可解决的大问题，分解为一个个小问题，然后逐个击破。

参考资料：

- [[http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Weiss/L17-ExternalSortEX1.htm]]
- [[http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Weiss/L17-ExternalSortEX2.htm]]

* 

即使有足够的内存去处理100GB的文件，我们也可以利用分治的思想，把问题分解为小问题，利用多核并发和分布式计算的优势，来加速计算。

* MapReduce

MapReduce是Google在04年发表的论文，运用分治的思想在大规模分布式系统中处理大数据计算。这篇论文开启了互联网大数据的浪潮，优秀的开源实现有Hadoop。

.image img/mapreduce.jpeg 500 800

* MapReduce

参考资料

- [[https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf]]
- [[http://blog.bizcloudsoft.com/wp-content/uploads/Google-MapReduce%E4%B8%AD%E6%96%87%E7%89%88_1.0.pdf]]

* 课后作业

阅读

	MapReduce论文

开发，需要编码实现以及分析算法复杂度，优劣及应用场景等
	
	1. 插入排序，选择排序，冒泡排序，希尔排序，归并排序，堆排序和快速排序
	2. 二分搜索
	3. 外部排序
	4. 熟悉go sort package

进阶练习

	1. 无序的数组，找第k大的数
	2. 并发排序：利用Go concurrency和多核CPU，加速排序
	3. 对各种排序方法，针对不同的应用场景，做benchmark

我在 *西七楼* 小密圈等你来答疑，更多的例程请关注公众号更新。