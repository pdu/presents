BAT后台开发入门
二叉树

peng
西七楼

* 二叉树

.image img/binary_tree.png 400 500

应用层的开发中，很少用到二叉树。但是底层系统或索引系统等，通常都构建在类似二叉树的数据结构上。

二叉树也是程序员面试中常考的数据结构。

* 二叉树

二叉树的几个要点：

- 有一个 *根节点(root)*
- 每个节点最多有两个 *子节点(child)*
- 没有子节点的称为 *叶子节点(leaf)*

也可以把二叉树看做 *有向无环图* ，以后介绍图算法的时候再详说。

* 二叉树的实现

.play -numbers linked_list/main.go /START1 OMIT/,/END1 OMIT/

一般用 *链表* 来实现二叉树：

	left 表示左儿子，left == nil 表示没有左儿子
	right 表示右儿子，right == nil 表示没有右儿子

* 二叉树的插入

.play -numbers linked_list/main.go /START2 OMIT/,/END2 OMIT/
.play -numbers linked_list/main.go /START3 OMIT/,/END3 OMIT/

* 二叉树的插入

把新插入的节点当做根节点：

- 第17-18行：
	如果根节点为空，置新节点为根节点
- 第19-20行：
	如果根节点没有左儿子，置根节点为新节点的左儿子
	置新节点为根节点
- 第22-24行：
	如果根节点有左儿子，置根节点的左儿子为新节点的左儿子，根节点为新节点的右儿子
	根节点的左儿子置空
	置新节点为根节点

二叉树的插入有多种算法，会导致二叉树的形状不一样。

* 二叉树的查找

.play -numbers linked_list/main.go /START4 OMIT/,/END4 OMIT/
.play -numbers linked_list/main.go /START5 OMIT/,/END5 OMIT/

* 二叉树的查找

遍历二叉树查找相应的节点：

- 第34-36行：节点为空则退出
- 第37-39行：节点是否为要找的值，是则退出
- 第40-42行：找节点的左儿子，找到则退出
- 第43行：找节点的右儿子

遍历的过程使用的是前面课程里介绍的 *递归算法*

* 二叉树的删除

.play -numbers linked_list/main.go /START6 OMIT/,/END6 OMIT/
.play -numbers linked_list/main.go /START7 OMIT/,/END7 OMIT/

* 二叉树的删除

遍历二叉树查找相应的节点，并删除：

- 第50-52行：节点为空则退出
- 第53-56行：节点即为要删除的节点，需要维持二叉树的结构
- 第54-55行：如果待删除节点为叶子节点，直接删除
- 第56-57行：如果待删除节点没有左儿子，则直接把右儿子放到待删除节点的位置
- 第58-59行：如果待删除节点没有右儿子，则直接把左儿子放到待删除节点的位置
- 第61-65行：如果待删除节点既有左儿子，又有右儿子
	找到左儿子第一个没有左儿子的节点，把右儿子作为该节点的左儿子
	把左儿子放到待删除节点的位置
- 第67-68行：递归节点的左儿子和右儿子，并且赋值左儿子和右儿子为新的返回值

删除的过程相对较复杂，根据不同的情况，保持二叉树的结构。

* 二叉树的遍历

二叉树的遍历一般用递归的方法，分为前序(pre-order)，中序(in-order)和后续(post-order)：

- 前序(pre-order)：先root，再left，最后right
- 中序(in-order)：先left，再root，最后right
- 后续(post-order)：先left，再right，最后root

left永远是在right前面，重点是看root在什么次序。

.play -numbers linked_list/main.go /START8 OMIT/,/END8 OMIT/

* 二叉树的遍历

.play -numbers linked_list/main.go /START9 OMIT/,/END9 OMIT/

* 二叉树的遍历

二叉树在内存中是链表的结构存储，如果要备份到硬盘要怎么做呢？

	前序，中序或者后续遍历之后，得到二叉树的序列，再备份。

如果备份后，如何恢复到内存中呢？

- 一种序列，是无法还原二叉树的结构的
- 前序、中序和后续中任意两种，可以还原二叉树的结构
	这个编码实现有点难度，留作课后习题。

* 二叉树的实现

.image img/binary-tree-array.png 300 600

二叉树也可以用数组来实现：

- 根节点下标：0
- 左儿子下标：2 * i + 1
- 右儿子下标：2 * i + 2

* 二叉搜索树

.image img/binary_search_tree.png 400 500

二叉搜索树是一种特殊的二叉树，主要是为了方便查找。

* 二叉搜索树

二叉搜索树的几个要点：

- 左子树都不大于根节点
- 右子树都不小于根节点
- 左子树和右子树都满足相同的规律

二叉搜索树的插入、查找、删除和遍历操作，类似二叉树的实现，只是有细节的差别，请大家自行实现。

* 二叉搜索树

二叉树的高度(Height)：

- 根节点的高度为0，根节点的儿子节点高度为1，依次递增
- 最远的叶子节点的高度，即为整棵树的高度

插入、查找和删除等操作的复杂度，应该是O(Height)。

- 保证二叉搜索树高效的条件就是：高度尽量低
- 节点个数为n的二叉树，最优节点高度是：O(log n)

* 之前实现的插入和删除方法：是否会使二叉树成为复杂度O(n)的单链表？

* 平衡二叉树

平衡二叉树就是专门解决这种问题的，可以自动的调整二叉树的高度尽量低。

大家需要重点了解一下红黑树(Red-black tree)：

	C++ STL/map背后的数据结构就是红黑树

可以参考这个链接的内容：[[https://www.cs.auckland.ac.nz/software/AlgAnim/red_black.html]]

* 其他的搜索树

工业界比较知名的搜索树还有：

- 数据库和文件系统使用较多的：
	B tree
	B+ tree
- Facebook开源的RocksDB键值对数据库：
	LSM tree

* 课后习题

- 代码练习
	二叉搜索树的插入，查找，删除
	二叉树的前序、中序和后续遍历
- 高级代码练习
	二叉树遍历的非递归实现
	已知任意两种遍历序列，构建二叉树
- 知识点了解
	红黑树，以及红黑树和AVL树的对比
	B tree和B+ tree的对比